<!DOCTYPE html>
<html lang="es">
<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-44Y9CNCHR8"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-44Y9CNCHR8');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
    <meta content='jucardus punto com, programación, traducciones, vocabularios, diccionario inglés-español, diccionario, perfil, sitio central, mis páginas, páginas favoritas, favoritas, escritos, contacto, traducciones, donaciones, pagos, actividad reciente, actividad, recientes, enlaces varios, enlaces, selección de enlaces, hipervínculos, vínculos, vínculos seleccionados, difusión, redes, redes de difusión, fotografías, invitación, invitación a la nube, invitación a pCloud, música, música clasica, canal de música, canal en YouTube, repositorio, cuenta en Twitter, cuenta en Tumblr, cuenta en Facebook, traducciones, servicio de traducciones, diccionarios, listas de reproducción, playlists, playlist' name='keywords'/>
    <meta content='Mi sitio central, con todas mis páginas.' name='description'/>
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <meta content='Julio Cárdenas Pelizzari' name='author'/>
    <title>REPOSITORIO JUCARDUS</title>
    <style>
        body {
            background-color: #333;
            background-color: #145;
            color: #eaeaea;
            margin: 0;
            padding: 50px 20% 100px 20%;
            line-height: 1.6;
            font-family: 'Inter', sans-serif;
            letter-spacint: 1px;
            min-height: 100vh;
        }
        a {
            color: #eee;
            text-decoration: none;
            border-bottom: 0.5px Solid #909090;
        }
        a:hover {
            color: Gold;
            border-bottom: 0.7px Solid Orange;
        }
        ul {
            padding-left: 20px;
            margin: 10px 0;
        }
        li {
            margin: 5px 0;
        }
        h1, h2, h3, h4 {
            color: #eee;
            border-bottom: 1px solid #666;
            margin: 0px 0px 0px 0px;
        }
        p {
            margin: 10px 0;
        }
        strong {
            font-weight: bold;
        }
        em {
            font-style: italic;
        }
        strong em, em strong {
            font-weight: bold;
            font-style: italic;
        }
        pre {
            background-color: #444;
            background-color: #034;
            background-color: #0e3948;
            padding: 0px 5px 0px 15px;
            border-radius: 5px;
            overflow-x: auto;
            font-family: monospace;
            white-space: pre;
            margin: 15px 0;
        }
        blockquote {
            background-color: #333;
            background-color: #034;
            background-color: #0e3948;
            padding: 0px 5px 0px 15px;
            border-radius: 5px;
            margin: 15px auto;
            font-family: "Times New Roman", Times, serif;
            font-size: 1.1em;
            line-height: 1.5;
            border-left: 4px solid #666;
            max-width: 90%;
        }
        #imagenes {
            text-align: center;
            margin: 20px 0;
        }
        .imagenes {
            max-width: 75%;
            height: auto;
            border-radius: 8px;
        }

        /* Sticky navigation menu */
        .sticky-nav {
            position: sticky;
            top: 0;
            background-color: #444;
            background-color: #034;
            background-color: #0e3948;
            padding: 10px 15px;
            margin: 0 0 0 0;
            margin-bottom: -5px!important;
            z-index: 100;
            border-bottom: 1px solid #555;
        }
        .sticky-nav a {
            margin: 0 5px;
        }

        /* Page separator */
        .page-separator {
            text-align: center;
            margin: 0px 0 0px 0;
            color: #999;
            font-size: 1.2em;
        }

        /* Mobile responsiveness */
        @media (max-width: 768px) {
            body {
                padding: 20px 5% 80px 5%;
            }
            .imagenes {
                max-width: 95%;
            }
            h1 {
                /*font-size: 1.5em;*/
            }
            h2 {
                font-size: 1.3em;
            }
            h3 {
                font-size: 1.1em;
            }
            pre {
                padding: 0px 5px 0px 8px;
                font-size: 0.9em;
            }
            blockquote {
                padding: 12px 15px;
                font-size: 1.05em;
                max-width: 95%;
            }
            .sticky-nav {
                margin: 0 0 15px 0;
                padding: 8px 10px;
            }
            .page-separator {
                margin: 0px 0 0px 0;
            }
        }

        @media (max-width: 480px) {
            body {
                padding: 15px 3% 60px 3%;
            }
            .imagenes {
                max-width: 95%;
            }
            ul {
                padding-left: 15px;
            }
            pre {
                padding: 0px 5px 0px 15px;
                font-size: 0.85em;
            }
            blockquote {
                padding: 10px 12px;
                font-size: 1em;
                max-width: 95%;
            }
            .sticky-nav {
                margin: 0 0 10px 0;
                padding: 6px 8px;
                font-size: 0.9em;
            }
            .page-separator {
                margin: 0px 0 0px 0;
            }
        }
    </style>
</head>
<body>
    <div id="content"></div>

    <script>
        // Configuration - CHANGE THIS to your repo
        const USER = 'jucardus';
        const REPO = 'jucardus.github.io';
        const BRANCH = 'main';

        const BASE_URL = `https://raw.githubusercontent.com/${USER}/${REPO}/${BRANCH}/`;
        const SITE_URL = `https://${USER}.github.io`;

        // Convert path to markdown path
        function pathToMdPath(path) {
            if (!path) return 'index.md';

            // If path doesn't have .md extension, add it
            if (!path.endsWith('.md')) {
                path += '.md';
            }

            return path;
        }

        // Convert GitHub URL to clean site URL
        function githubUrlToSiteUrl(githubUrl) {
            if (!githubUrl.includes('github.com')) return githubUrl;

            // Extract path from GitHub blob URL
            const match = githubUrl.match(/github\.com\/[^\/]+\/[^\/]+\/blob\/[^\/]+\/(.+\.md)/);
            if (match) {
                const mdPath = match[1];
                // Remove .md extension for clean URL
                const cleanPath = mdPath.replace(/\.md$/, '');
                // return `${SITE_URL}/${cleanPath}`;
                return `${SITE_URL}/github.html#${cleanPath}`;
            }

            return githubUrl;
        }

        // Extract relative path from GitHub URL
        function extractRelativePath(url) {
            if (!url.includes('github.com')) return url;

            // Extract path from GitHub blob URL
            const match = url.match(/github\.com\/[^\/]+\/[^\/]+\/blob\/[^\/]+\/(.+\.md)/);
            if (match) {
                return match[1];
            }

            // Extract path from raw GitHub URL
            const rawMatch = url.match(/raw\.githubusercontent\.com\/[^\/]+\/[^\/]+\/[^\/]+\/(.+\.md)/);
            if (rawMatch) {
                return rawMatch[1];
            }

            return url;
        }

        // Get current page from URL hash
        function getCurrentPage() {
            const hash = window.location.hash.substring(1);
            return pathToMdPath(hash) || 'index.md';
        }

        // Convert any GitHub URL to raw URL
        function toRawUrl(url) {
            if (url.includes('github.com') && url.includes('/blob/')) {
                return url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');
            }
            return url;
        }

        // Check if URL is a GitHub .md file in our repo
        function isInternalLink(url) {
            return url.includes(USER) && url.includes(REPO) && url.includes('.md');
        }

        // Check if URL is a Twitter/X share link and modify it
        function isShareLink(url) {
            return url.includes('https://x.com/intent/tweet?text=') ||
                   url.includes('https://twitter.com/intent/tweet?text=');
        }

        // Modify share URL to use clean site URLs
        function modifyShareUrl(url, currentPagePath) {
            if (!isShareLink(url)) return url;

            // Extract the text parameter from the current share URL
            const urlParams = new URLSearchParams(url.split('?')[1]);
            let text = urlParams.get('text') || '';

            // Replace GitHub URLs with clean site URLs in the text
            text = text.replace(
                /https:\/\/github\.com\/[^\/]+\/[^\/]+\/blob\/[^\/]+\/(.+\.md)/g,
                (match, mdPath) => {
                    const cleanPath = mdPath.replace(/\.md$/, '');
                    return `${SITE_URL}/${cleanPath}`;
                }
            );

            // Update the text parameter
            urlParams.set('text', text);

            // Reconstruct the URL
            const baseUrl = url.split('?')[0];
            return `${baseUrl}?${urlParams.toString()}`;
        }

        // Check if text looks like a navigation menu
        function isNavigationMenu(text) {
            const navPatterns = [
                /inicio.*índice.*etiquetas.*actividad.*compartir/i,
                /inicio.*index.*tags.*activity.*share/i,
                /\[.*inicio.*\].*\[.*índice.*\].*\[.*etiquetas.*\].*\[.*actividad.*\].*\[.*compartir.*\]/i
            ];
            return navPatterns.some(pattern => pattern.test(text));
        }

        // Process blockquotes
        function processBlockquotes(text) {
            const lines = text.split('\n');
            let inBlockquote = false;
            let blockquoteContent = '';
            let result = '';

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];

                if (line.startsWith('> ')) {
                    if (!inBlockquote) {
                        inBlockquote = true;
                        blockquoteContent = line.substring(2);
                    } else {
                        blockquoteContent += '<br>' + line.substring(2);
                    }
                } else {
                    if (inBlockquote) {
                        result += `<blockquote>${blockquoteContent}</blockquote>`;
                        inBlockquote = false;
                        blockquoteContent = '';
                    }
                    result += line + '\n';
                }
            }

            // Close any open blockquote at the end
            if (inBlockquote) {
                result += `<blockquote>${blockquoteContent}</blockquote>`;
            }

            return result;
        }

        // Process images with custom styling
        function processImages(text, basePath) {
            return text.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, imageUrl) {
                let fullImageUrl = imageUrl;

                // Handle relative image paths
                if (imageUrl.startsWith('./') || imageUrl.startsWith('../') || !imageUrl.includes('://')) {
                    const basePath = basePath.substring(0, basePath.lastIndexOf('/') + 1);
                    if (imageUrl.startsWith('./')) {
                        fullImageUrl = BASE_URL + basePath + imageUrl.substring(2);
                    } else if (imageUrl.startsWith('../')) {
                        let path = basePath;
                        let relPath = imageUrl;
                        while (relPath.startsWith('../')) {
                            path = path.substring(0, path.lastIndexOf('/', path.length - 2) + 1);
                            relPath = relPath.substring(3);
                        }
                        fullImageUrl = BASE_URL + path + relPath;
                    } else if (!imageUrl.includes('://')) {
                        fullImageUrl = BASE_URL + basePath + imageUrl;
                    }
                }

                return `<div id="imagenes"><img src="${fullImageUrl}" alt="${altText}" class="imagenes"></div>`;
            });
        }

        // Process code blocks with ``` delimiters
        function processCodeBlocks(text) {
            let result = '';
            let i = 0;
            let inCodeBlock = false;
            let codeContent = '';

            while (i < text.length) {
                // Look for code block delimiters ```
                if (text[i] === '`' && i + 2 < text.length && text[i + 1] === '`' && text[i + 2] === '`') {
                    if (!inCodeBlock) {
                        // Start of code block
                        inCodeBlock = true;
                        i += 3;
                        codeContent = '';
                    } else {
                        // End of code block
                        inCodeBlock = false;
                        result += `<pre>${codeContent}</pre>`;
                        i += 3;
                    }
                    continue;
                }

                if (inCodeBlock) {
                    // Collect code content
                    codeContent += text[i];
                    i++;
                } else {
                    // Regular text
                    result += text[i];
                    i++;
                }
            }

            // If we're still in a code block at the end, close it
            if (inCodeBlock) {
                result += `<pre>${codeContent}</pre>`;
            }

            return result;
        }

        // Process text formatting in correct order
        function processTextFormatting(text) {
            let result = text;

            // Process in correct order: 1. ***bold-italic***, 2. **bold**, 3. *italic*

            // 1. Bold-italic (***text***)
            result = result.replace(/\*\*\*(.*?)\*\*\*/g, '<strong><em>$1</em></strong>');

            // 2. Bold (**text**)
            result = result.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');

            // 3. Italic (*text*)
            result = result.replace(/\*(.*?)\*/g, '<em>$1</em>');

            return result;
        }

        // Process links in text - handles nested brackets
        function processLinks(text, basePath, currentPagePath) {
            let result = '';
            let i = 0;

            while (i < text.length) {
                // Look for the start of a link
                if (text[i] === '[' && i + 1 < text.length) {
                    let bracketCount = 1;
                    let j = i + 1;

                    // Find the matching closing bracket for the link text
                    while (j < text.length && bracketCount > 0) {
                        if (text[j] === '[') bracketCount++;
                        if (text[j] === ']') bracketCount--;
                        j++;
                    }

                    // If we found the closing bracket, look for the URL part
                    if (bracketCount === 0 && j < text.length && text[j] === '(') {
                        let k = j + 1;
                        let parenCount = 1;

                        // Find the matching closing parenthesis for the URL
                        while (k < text.length && parenCount > 0) {
                            if (text[k] === '(') parenCount++;
                            if (text[k] === ')') parenCount--;
                            k++;
                        }

                        if (parenCount === 0) {
                            // Extract link text and URL
                            const linkText = text.substring(i + 1, j - 1);
                            let url = text.substring(j + 1, k - 1);

                            // Check for share links FIRST (before any URL processing)
                            if (isShareLink(url)) {
                                // Modify share URL to use clean site URLs
                                const modifiedUrl = modifyShareUrl(url, currentPagePath);
                                result += `<a href="${modifiedUrl}" target="_blank" rel="noopener noreferrer nofollow external">${linkText}</a>`;
                                i = k;
                                continue;
                            }

                            let fullUrl = url;

                            // Handle relative URLs
                            if (url.startsWith('./') || url.startsWith('../') || !url.includes('://')) {
                                const basePath = basePath.substring(0, basePath.lastIndexOf('/') + 1);
                                if (url.startsWith('./')) {
                                    fullUrl = BASE_URL + basePath + url.substring(2);
                                } else if (url.startsWith('../')) {
                                    let path = basePath;
                                    let relPath = url;
                                    while (relPath.startsWith('../')) {
                                        path = path.substring(0, path.lastIndexOf('/', path.length - 2) + 1);
                                        relPath = relPath.substring(3);
                                    }
                                    fullUrl = BASE_URL + path + relPath;
                                } else if (!url.includes('://')) {
                                    fullUrl = BASE_URL + basePath + url;
                                }
                            }

                            if (isInternalLink(fullUrl)) {
                                // Store only the relative path in data-url
                                const relativePath = extractRelativePath(fullUrl);
                                result += `<a href="#" data-url="${relativePath}">${linkText}</a>`;
                            } else {
                                result += `<a href="${url}" target="_blank" rel="noopener noreferrer nofollow external">${linkText}</a>`;
                            }

                            i = k;
                            continue;
                        }
                    }
                }

                // If not a link, just add the character
                result += text[i];
                i++;
            }

            return result;
        }

        // Add page separator to content
        function addPageSeparator(html) {
            return html + '<div class="page-separator">~ • ~</div>';
        }

        // Simple markdown to HTML converter
        function renderMarkdown(text, currentPath) {
            const basePath = currentPath.includes('/')
                ? currentPath.substring(0, currentPath.lastIndexOf('/') + 1)
                : '';

            let html = text;

            // Process blockquotes FIRST
            html = processBlockquotes(html);

            // Process code blocks SECOND
            html = processCodeBlocks(html);

            // Process images THIRD
            html = processImages(html, currentPath);

            // Process ALL links (pass currentPath for share URL modification)
            html = processLinks(html, basePath, currentPath);

            // Convert headers
            html = html.replace(/^#### (.*$)/gm, '<h4>$1</h4>');
            html = html.replace(/^### (.*$)/gm, '<h3>$1</h3>');
            html = html.replace(/^## (.*$)/gm, '<h2>$1</h2>');
            html = html.replace(/^# (.*$)/gm, '<h1>$1</h1>');

            // Process text formatting AFTER links and code blocks
            html = processTextFormatting(html);

            // Convert lists and handle paragraphs
            const lines = html.split('\n');
            let inList = false;
            let inParagraph = false;
            let newHtml = '';

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const trimmedLine = line.trim();

                // Skip processing for lines inside pre tags (code blocks) or blockquotes
                if (line.includes('<pre>') || line.includes('<blockquote>') ||
                    (inParagraph && (line.includes('</pre>') || line.includes('</blockquote>')))) {
                    if (inParagraph) {
                        newHtml += '</p>';
                        inParagraph = false;
                    }
                    if (inList) {
                        newHtml += '</ul>';
                        inList = false;
                    }
                    newHtml += line;
                    continue;
                }

                // Handle headers - they break paragraphs
                if (trimmedLine.startsWith('<h1>') || trimmedLine.startsWith('<h2>') || trimmedLine.startsWith('<h3>')) {
                    if (inParagraph) {
                        newHtml += '</p>';
                        inParagraph = false;
                    }
                    if (inList) {
                        newHtml += '</ul>';
                        inList = false;
                    }
                    newHtml += line;
                    continue;
                }

                // Handle list items (look for * at start of line)
                if (line.startsWith('* ') && !line.startsWith('* *')) {
                    if (inParagraph) {
                        newHtml += '</p>';
                        inParagraph = false;
                    }

                    if (!inList) {
                        newHtml += '<ul>';
                        inList = true;
                    }
                    // Convert the list item
                    let listItem = line.substring(2);
                    newHtml += `<li>${listItem}</li>`;
                    continue;
                }

                // Handle empty lines (paragraph breaks)
                if (trimmedLine === '') {
                    if (inParagraph) {
                        newHtml += '</p>';
                        inParagraph = false;
                    }
                    if (inList) {
                        newHtml += '</ul>';
                        inList = false;
                    }
                    newHtml += '<br>'; // Blank line
                    continue;
                }

                // Check if this line is a navigation menu and wrap it
                let processedLine = line;
                if (isNavigationMenu(line)) {
                    processedLine = `<div class="sticky-nav">${line}</div>`;
                }

                // Handle regular text (start or continue paragraph)
                if (!inParagraph) {
                    newHtml += '<p>';
                    inParagraph = true;
                } else {
                    newHtml += '<br>'; // Line break within paragraph
                }
                newHtml += processedLine;
            }

            // Close any open tags
            if (inParagraph) {
                newHtml += '</p>';
            }
            if (inList) {
                newHtml += '</ul>';
            }

            // Add page separator at the end
            newHtml = addPageSeparator(newHtml);

            return newHtml;
        }

        // Load a page
        async function loadPage(url) {
            const contentDiv = document.getElementById('content');

            try {
                let fetchUrl;
                if (url.startsWith('http')) {
                    fetchUrl = toRawUrl(url);
                } else {
                    // For relative paths, construct the full URL
                    fetchUrl = BASE_URL + url;
                }

                const response = await fetch(fetchUrl);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);

                const markdown = await response.text();

                contentDiv.innerHTML = renderMarkdown(markdown, url);

                // Update URL hash
                window.location.hash = url.startsWith('http') ? extractRelativePath(url) : url;

                // Scroll to top after loading new page
                window.scrollTo(0, 0);

            } catch (error) {
                console.error('Error:', error);
                contentDiv.innerHTML = `
                    Error loading: ${url}<br><br>
                    <a href="#" onclick="loadPage('index.md')">Go to homepage</a>
                `;
                // Scroll to top on error too
                window.scrollTo(0, 0);
            }
        }

        // Handle link clicks
        document.addEventListener('click', (e) => {
            if (e.target.tagName === 'A') {
                const url = e.target.getAttribute('data-url');
                if (url) {
                    e.preventDefault();
                    loadPage(url);
                }
            }
        });

        // Handle browser back/forward
        window.addEventListener('hashchange', () => {
            loadPage(getCurrentPage());
        });

        // Start the app
        loadPage(getCurrentPage());
    </script>
</body>
</html>
